# FloatingPanel 重构计划

## 当前问题分析

### 1. 代码过长
- 当前 `floatingPanel.ts` 文件有 1916 行
- 违反了单一职责原则
- 难以维护和测试

### 2. 职责混乱
- UI渲染、事件处理、数据管理、样式注入、拖拽功能等混在一起
- 方法之间耦合度高
- 代码重复严重

### 3. 可维护性差
- 一个文件承担太多职责
- 难以定位和修改特定功能
- 团队协作困难

## 重构目标

### 1. 提高可维护性
- 每个文件职责单一
- 降低耦合度
- 提高代码可读性

### 2. 提高可测试性
- 组件可以单独测试
- 功能模块化
- 便于单元测试

### 3. 提高可扩展性
- 新增功能更容易
- 组件可复用
- 支持插件化

## 文件结构设计

```
src/content/panels/
├── FloatingPanel.ts          // 主面板类（精简后，200-300行）
├── PanelRenderer.ts          // UI渲染逻辑（300-400行）
├── PanelStyles.ts            // 样式管理（200-300行）
├── PanelEvents.ts            // 事件处理（400-500行）
├── PanelDragHandler.ts       // 拖拽功能（150-200行）
├── PanelTooltip.ts           // Tooltip功能（100-150行）
└── PanelTheme.ts             // 主题管理（50-100行）
```

## 详细拆分方案

### 1. FloatingPanel.ts (主类)
**职责：**
- 协调各个组件
- 管理生命周期
- 对外接口
- 状态管理

**包含内容：**
- 构造函数和初始化
- 公共方法（show/hide/toggle等）
- 组件协调逻辑
- 状态管理

### 2. PanelRenderer.ts (渲染器)
**职责：**
- 创建DOM结构
- 管理UI元素引用
- 渲染逻辑

**包含内容：**
- createPanel() 方法
- DOM元素创建
- 布局管理
- UI元素引用

### 3. PanelStyles.ts (样式管理)
**职责：**
- 所有CSS样式
- 主题相关样式
- 动态样式注入

**包含内容：**
- injectStyles() 方法
- 所有CSS规则
- 主题样式
- 动态样式更新

### 4. PanelEvents.ts (事件处理)
**职责：**
- 所有事件监听器
- 事件处理逻辑
- Eddy相关事件

**包含内容：**
- setupEddyEventHandlers()
- 按钮事件处理
- 输入框事件
- 全局事件监听

### 5. PanelDragHandler.ts (拖拽处理)
**职责：**
- 拖拽功能
- 位置计算
- 边界检测

**包含内容：**
- 拖拽事件处理
- 位置计算逻辑
- 边界检测
- 视口适配

### 6. PanelTooltip.ts (Tooltip功能)
**职责：**
- Tooltip创建和显示
- 位置计算
- 样式管理

**包含内容：**
- createTooltip()
- showTooltip()
- hideTooltip()
- 位置计算逻辑

### 7. PanelTheme.ts (主题管理)
**职责：**
- 主题切换
- 深色模式检测
- 主题相关逻辑

**包含内容：**
- toggleTheme()
- 主题检测
- 主题状态管理

## 迁移策略

### 阶段1：样式提取
1. 创建 `PanelStyles.ts`
2. 提取所有CSS样式
3. 保持现有功能不变

### 阶段2：工具功能提取
1. 创建 `PanelTooltip.ts`
2. 创建 `PanelTheme.ts`
3. 提取相关功能

### 阶段3：事件处理提取
1. 创建 `PanelEvents.ts`
2. 提取事件处理逻辑
3. 保持事件绑定不变

### 阶段4：拖拽功能提取
1. 创建 `PanelDragHandler.ts`
2. 提取拖拽相关代码
3. 保持拖拽功能正常

### 阶段5：渲染逻辑提取
1. 创建 `PanelRenderer.ts`
2. 提取DOM创建逻辑
3. 重构主类

### 阶段6：主类精简
1. 精简 `FloatingPanel.ts`
2. 协调各个组件
3. 优化接口设计

## 预期收益

### 1. 代码质量提升
- 文件大小控制在合理范围
- 职责清晰，易于理解
- 减少代码重复

### 2. 开发效率提升
- 定位问题更容易
- 修改功能更安全
- 新增功能更简单

### 3. 团队协作改善
- 不同开发者可以并行开发
- 代码审查更容易
- 知识传递更简单

### 4. 可维护性提升
- 模块化设计
- 低耦合高内聚
- 便于重构和优化

## 注意事项

### 1. 向后兼容
- 确保现有功能不受影响
- 保持公共接口不变
- 渐进式迁移

### 2. 测试覆盖
- 每个模块都要有测试
- 确保功能完整性
- 回归测试

### 3. 性能考虑
- 避免过度设计
- 保持性能不下降
- 合理的内存使用

## 下一步行动

等待具体指令，按计划逐步执行重构工作。 